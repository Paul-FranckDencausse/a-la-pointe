/* Programmes Optimove - ESP32-S3
   - 4 modes: INITIATION, LOISIR, PERFORMEURS, SERIE
   - Mesure temps de réaction par cible
   - Buzzer unique
   - Envoi Serial (format simple)
   - Optional BLE: activer #define USE_BLE 1 (prévoir NimBLE lib)
*/

#include <Arduino.h>

// -> Si tu veux le BLE, active et ajoute NimBLE-Arduino dans ton platform
// #define USE_BLE 1

#ifdef USE_BLE
// Nécessite la lib NimBLE-Arduino
#include <NimBLEDevice.h>
#endif

// Pin definitions (vérifie correspondance avec ton schéma)
#define SYSTEM_LED    9
#define ULN_BUZZER    10
#define ULN_LED1      11
#define ULN_LED2      18
#define ULN_LED3      19
#define ULN_LED4      20
#define ULN_LED5      21

#define USER_SW       25

#define TARGET1_STATE 28
#define TARGET2_STATE 31
#define TARGET3_STATE 34
#define TARGET4_STATE 35
#define TARGET5_STATE 38

#define TARGET1       29
#define TARGET2       32
#define TARGET3       33
#define TARGET4       36
#define TARGET5       37

// Nombre de cibles
#define TARGET_COUNT 5

// Tableau des LEDs & états
const int targetPins[TARGET_COUNT] = {ULN_LED1, ULN_LED2, ULN_LED3, ULN_LED4, ULN_LED5};
const int targetStates[TARGET_COUNT] = {TARGET1_STATE, TARGET2_STATE, TARGET3_STATE, TARGET4_STATE, TARGET5_STATE};

// Mode énumération
enum Mode { INITIATION=0, LOISIR=1, PERFORMEURS=2, SERIE=3 };
const char* modeNames[] = {"INITIATION","LOISIR","PERFORMEURS","SERIE"};
Mode currentMode = INITIATION;

// Paramètres de session (ajustables)
int maxHits = 5;             // max cibles par session
unsigned long lastTargetMillis = 0;
unsigned long interTargetDelay = 1000; // utilisé comme délai entre cycles (si nécessaire)
bool sessionRunning = false;

// Variables runtime
int currentTargetsMask = 0; // bitmask des cibles allumées actuellement
unsigned long activationTimestamps[TARGET_COUNT]; // moment d'allumage par cible (ms)
bool targetAwaitingHit[TARGET_COUNT]; // true si cible attend un hit
int hitsCount = 0;

// Debounce & bouton
unsigned long lastButtonChange = 0;
bool lastButtonState = HIGH;
unsigned long buttonPressStart = 0;
const unsigned long debounceMs = 40;
const unsigned long longPressMs = 800;

// Timing et paramètres par mode
struct ModeParams {
  float minDelaySec; // délai minimal entre LED et capteur (s)
  float maxDelaySec; // délai max utilisé pour délai adaptatif (s)
  int minTargets;    // min cibles simultanées
  int maxTargets;    // max cibles simultanées
  bool allowMultiple;
};

ModeParams paramsByMode[] = {
  // INITIATION: long délai 3s, 1 cible
  {3.0, 3.0, 1, 1, false},
  // LOISIR: 1.5-2s, 1..3 cibles
  {1.5, 2.0, 1, 3, true},
  // PERFORMEURS: 0.5-1s, 3..5 cibles
  {0.5, 1.0, 3, 5, true},
  // SERIE: pas de délai, toutes les cibles allumées
  {0.0, 0.0, TARGET_COUNT, TARGET_COUNT, true}
};

// Résultats
struct HitResult { int targetIndex; unsigned long reactionMs; };
HitResult results[ TARGET_COUNT * 10 ]; // simple buffer
int resultsLen = 0;

// --- Helper ---
void publishSerial(const String &s) {
  Serial.println(s);
#ifdef USE_BLE
  // TODO: forward via BLE notify si implémenté
#endif
}

// Allume / éteint une cible (physique)
void setTarget(int idx, bool on) {
  if (idx < 0 || idx >= TARGET_COUNT) return;
  digitalWrite(targetPins[idx], on ? HIGH : LOW);
  if (!on) {
    activationTimestamps[idx] = 0;
    targetAwaitingHit[idx] = false;
  } else {
    activationTimestamps[idx] = millis();
    targetAwaitingHit[idx] = true;
  }
}

// Eteint toutes les cibles
void clearAllTargets() {
  currentTargetsMask = 0;
  for (int i=0;i<TARGET_COUNT;i++) setTarget(i,false);
}

// Choisit aléatoirement N cibles distinctes et allume
void activateRandomTargets(int n) {
  clearAllTargets();
  if (n <= 0) return;
  int chosen = 0;
  while (chosen < n) {
    int r = random(0, TARGET_COUNT);
    int bit = 1<<r;
    if ((currentTargetsMask & bit) == 0) {
      currentTargetsMask |= bit;
      setTarget(r, true);
      chosen++;
      publishSerial(String("EVENT:NEW_TARGET:") + String(r+1));
    }
  }
}

// Allume toutes les cibles (Série)
void activateAllTargets() {
  clearAllTargets();
  for (int i=0;i<TARGET_COUNT;i++) {
    currentTargetsMask |= (1<<i);
    setTarget(i,true);
    publishSerial(String("EVENT:NEW_TARGET:") + String(i+1));
  }
}

// Buzzer simple (ton unique)
void beep(unsigned ms=120) {
  digitalWrite(ULN_BUZZER, HIGH);
  digitalWrite(SYSTEM_LED, HIGH);
  delay(ms);
  digitalWrite(ULN_BUZZER, LOW);
  digitalWrite(SYSTEM_LED, LOW);
}

// Démarre la session
void startSession() {
  if (sessionRunning) return;
  sessionRunning = true;
  hitsCount = 0;
  resultsLen = 0;
  publishSerial(String("EVENT:SESSION_START:MODE=") + modeNames[currentMode]);
  // initial activation selon mode
  if (currentMode == SERIE) {
    activateAllTargets();
  } else {
    ModeParams p = paramsByMode[currentMode];
    int n = (p.minTargets == p.maxTargets) ? p.minTargets : random(p.minTargets, p.maxTargets+1);
    activateRandomTargets(n);
  }
  lastTargetMillis = millis();
}

// Stop session
void stopSession() {
  if (!sessionRunning) return;
  sessionRunning = false;
  clearAllTargets();
  publishSerial("EVENT:SESSION_END");
}

// Reset session data (sans changer le mode)
void resetSessionData() {
  hitsCount = 0;
  resultsLen = 0;
  clearAllTargets();
  publishSerial("EVENT:DATA_RESET");
}

// Check hits: lire toutes les inputs targetStates et traiter
void checkTargets() {
  for (int i=0;i<TARGET_COUNT;i++) {
    if (!targetAwaitingHit[i]) continue; // ignore si pas active
    int state = digitalRead(targetStates[i]);
    // on suppose HIGH = touché ; si inverse, remplacer par (state == LOW)
    if (state == HIGH) {
      unsigned long reaction = millis() - activationTimestamps[i];
      // Store
      if (resultsLen < (int)(sizeof(results)/sizeof(results[0]))) {
        results[resultsLen++] = {i, reaction};
      }
      hitsCount++;
      // feedback
      beep(120);
      publishSerial(String("EVENT:HIT:") + String(i+1) + String(":reaction=") + String(reaction));
      // éteindre la cible touchée
      setTarget(i,false);
      // Dans SERIE, on attend les autres cibles ; dans autres modes on peut ré-activer après un délai
      // Pour simplicité, on ne réactive immédiatement que si sessionRunning and not SERIE
    }
  }
}

// Logic cycle (scheduling targets)
void schedulingLoop() {
  if (!sessionRunning) return;
  ModeParams p = paramsByMode[currentMode];

  // SERIE mode = all targets on, wait until all off
  if (currentMode == SERIE) {
    bool anyAwaiting = false;
    for (int i=0;i<TARGET_COUNT;i++) if (targetAwaitingHit[i]) anyAwaiting = true;
    if (!anyAwaiting) {
      // all targets turned off -> session finished
      publishSerial("EVENT:SERIE_COMPLETE");
      stopSession();
    }
    return;
  }

  // For other modes, if no active target or all current targets expired, reactivate
  bool anyActive = false;
  unsigned long now = millis();
  for (int i=0;i<TARGET_COUNT;i++) {
    if (targetAwaitingHit[i]) {
      anyActive = true;
      // compute per-mode timeout window: we use p.maxDelaySec as timeout
      float timeoutSec = p.maxDelaySec;
      if ((now - activationTimestamps[i]) > (unsigned long)(timeoutSec*1000.0)) {
        // consider missed, turn off target
        setTarget(i,false);
        publishSerial(String("EVENT:MISS:") + String(i+1));
      }
    }
  }

  // If no active targets, schedule new activation after an optional inter-target delay
  if (!anyActive) {
    // small random jitter to avoid predictable rhythm
    unsigned long jitter = random(150, 450);
    if (now - lastTargetMillis >= interTargetDelay + jitter) {
      int n = random(paramsByMode[currentMode].minTargets, paramsByMode[currentMode].maxTargets + 1);
      activateRandomTargets(n);
      lastTargetMillis = now;
    }
  }
}

// Manage user button: short press cycle mode, long press start/stop
void handleButton() {
  bool reading = digitalRead(USER_SW);
  unsigned long now = millis();
  if (reading != lastButtonState && (now - lastButtonChange) > debounceMs) {
    lastButtonChange = now;
    lastButtonState = reading;
    if (reading == LOW) {
      // pressed (assuming INPUT_PULLUP)
      buttonPressStart = now;
    } else {
      // released
      unsigned long pressDur = now - buttonPressStart;
      if (pressDur >= longPressMs) {
        // long press -> start/stop
        if (sessionRunning) {
          stopSession();
        } else {
          startSession();
        }
      } else {
        // short press -> cycle mode (only when not running)
        if (!sessionRunning) {
          int next = (int(currentMode) + 1) % 4;
          currentMode = Mode(next);
          publishSerial(String("EVENT:MODE_CHANGE:") + modeNames[currentMode]);
          // set reasonable interTargetDelay per mode
          if (currentMode == INITIATION) interTargetDelay = 3000;
          else if (currentMode == LOISIR) interTargetDelay = 1700;
          else if (currentMode == PERFORMEURS) interTargetDelay = 800;
          else interTargetDelay = 0;
        }
      }
    }
  }
}

// Parse simple serial commands (optionnel)
void checkSerialCommands() {
  while (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();
    if (cmd.length() == 0) continue;
    // Examples:
    // START, STOP, MODE=LOISIR, RESET
    if (cmd.equalsIgnoreCase("START")) startSession();
    else if (cmd.equalsIgnoreCase("STOP")) stopSession();
    else if (cmd.equalsIgnoreCase("RESET")) resetSessionData();
    else if (cmd.startsWith("MODE=")) {
      String m = cmd.substring(5);
      m.toUpperCase();
      if (m == "INITIATION") currentMode = INITIATION;
      else if (m == "LOISIR") currentMode = LOISIR;
      else if (m == "PERFORMEURS") currentMode = PERFORMEURS;
      else if (m == "SERIE") currentMode = SERIE;
      publishSerial(String("EVENT:MODE_CHANGE:") + modeNames[currentMode]);
    } else if (cmd.startsWith("MAXHITS=")) {
      int v = cmd.substring(8).toInt();
      if (v > 0) maxHits = v;
    } else {
      publishSerial(String("EVENT:UNKNOWN_CMD:") + cmd);
    }
  }
}

void setupPins() {
  pinMode(SYSTEM_LED, OUTPUT);
  pinMode(ULN_BUZZER, OUTPUT);
  for (int i=0;i<TARGET_COUNT;i++) {
    pinMode(targetPins[i], OUTPUT);
    pinMode(targetStates[i], INPUT); // si besoin INPUT_PULLUP, ajuster selon ton capteur
  }
  pinMode(USER_SW, INPUT_PULLUP);
}

void setup() {
  Serial.begin(115200);
  delay(10);
  setupPins();
  randomSeed(analogRead(0));
  publishSerial("EVENT:BOOT");
  publishSerial(String("INFO:Mode par défaut:") + modeNames[currentMode]);
#ifdef USE_BLE
  // TODO: initialiser BLE et une characteristic de notify si nécessaire
  publishSerial("INFO:BLE_ENABLED");
#endif
}

void loop() {
  // bouton et commandes
  handleButton();
  checkSerialCommands();

  // check hits physiquement
  checkTargets();

  // scheduling logic
  schedulingLoop();

  // Arrêter si on atteint max hits (global)
  if (hitsCount >= maxHits && sessionRunning) {
    publishSerial(String("EVENT:MAX_HITS_REACHED:") + String(hitsCount));
    stopSession();
  }

  // petit délai pour ne pas saturer la loop
  delay(10);
}
